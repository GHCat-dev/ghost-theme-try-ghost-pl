<p>If you want to know a simple way to add a beautiful, fully functional contact form to your Ghost website <em>without paying for external services</em>, you finally came to the right spot. I'm going to show you how to do it with a bit of html, css, javascript and server side scripting.</p><p>While this method will save you real money by avoiding additional monthly subscription fees, it also does not give away your precious visitors' contact data to other companies. This would be unavoidable, if you were to connect your form to external services.</p><p>This tutorial is a step-by-step guide and the <em>best starting point</em> for getting your contact page up and running. Once you are familiar with the concepts, also check out <a href=\"https://github.com/styxlab/ghost-contact-form\">ghost-contact-form</a> on Github, which complements this article.</p><h2 id=\"just-a-blog\">Just a blog?</h2><p>Whilst looking around for a modern, clean and easy to use blogging platform <a href=\"https://ghost.org/3/\">Ghost 3</a> became quickly the number one choice for our new <a href=\"https://atmolabs.org/atmolabs-greenhouse-gas-measurements\">atmospheric measurement project</a>. As an open source project available on Github and built on a modern node.js stack, Ghost holds the promise to perform fast and integrate well with modern tools.</p><p>Probably one of the most basic features of any website is the ability to get in contact with the authors. To my surprise, <em>setting up a simple contact form on this Ghost blog wasn't as easy as I expected it to be</em>. Even more appalling, most solutions I came across point unerringly towards paid external services! Here is what the Ghost developers have to say on their forum:</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://forum.ghost.org/t/how-can-i-add-a-contact-form-to-my-blog-without-using-external-service/797/2\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">How can i add a contact form to my blog without using external service?</div><div class=\"kg-bookmark-description\">No way to do it locally, you would need to use an external svc ðŸ™‚</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://aws1.discourse-cdn.com/business4/uploads/ghost2/optimized/1X/c490d4018a44dd605e7bf4fdc6fdd4a3bc45c26e_2_180x180.png\"><span class=\"kg-bookmark-author\">Foseydon_Tanri</span><span class=\"kg-bookmark-publisher\">Ghost Forum</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://aws1.discourse-cdn.com/business4/uploads/ghost2/original/1X/c490d4018a44dd605e7bf4fdc6fdd4a3bc45c26e.png\"></div></a></figure><p>What a bummer! If you are willing to spend $10 each month, just to get a contact form running, then don't read any further! There are plenty of paid options available to you.</p><p>This is <em>not</em> an option for me! What's the benefit of an open source, modern stack software, if it does not mean easy integration of a <em>simple contact form</em>? And how much do I need to pay for other services, if I want to add more advanced features to my blog, for example, a search or commenting function?</p><p>Of course, there is always the possibility to fork the <a href=\"https://github.com/TryGhost/Ghost\">Ghost project on Github</a> and rewrite the server code to handle a contact form. It's like using a sledgehammer to crack a nut. That's definitely a complex and time consuming task. Even worse, it inhibits automatic updates to your blog software. <em>There must be a better way to do this! </em></p><p>At this point I was actually looking around for <em>just another </em>blog software, applauding to this well opinionated post:</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://nehalist.io/why-i-dont-like-the-ghost-blogging-platform-anymore/\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Why I donâ€™t like the Ghost blogging platform anymore</div><div class=\"kg-bookmark-description\">Iâ€™m using the Ghost blogging platform for more than four years now - and I donâ€™t like it anymore. Hereâ€™s why.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://nehalist.io/icons/icon-512x512.png?v=367459bc1b587ad1a953c82f84728b9f\"><span class=\"kg-bookmark-publisher\">nehalist.io</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://ghost.nehalist.io/content/images/2019/05/ghost-cover-1.png\"></div></a></figure><p>I think Kevin has a strong point to which the Ghost developers should better listen to.</p><p>However, reaching a dead end sometimes gives way to completely new ideas. And here is the question that lead me into the right direction: </p><blockquote><strong>What do these external services do that you can't do yourself?</strong></blockquote><p>After reading this post, you'll know the answer. Don't worry, I won't replicate these full-fledged services. But hey â€“ <em>all we want is a simple contact page!</em></p><h2 id=\"how-to-add-a-contact-page-to-ghost\">How to add a Contact Page to Ghost</h2><p>As you may have guessed by now, I am going to replace the paid external service with <em>my own micro-service</em> that I caringly call <em>ghost-contact-svc</em>.</p><p>This micro-service can be extended to perform other functions too, as you will see later. Also note that <em>ghost-contact-svc</em> has no additional dependencies, as it operates on the same stack as Ghost does. </p><p>On the front-end, I will add some simple html, css and javascript that you can copy-paste into the Ghost Admin interface. Here, I'm inspired by the work from Dana:</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://hooshmand.net/html-contact-forms-in-ghost/\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Beautiful Forms in Ghost â€” Using HTML</div><div class=\"kg-bookmark-description\">Creating beautiful contact forms in Ghost using pure HTML.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://hooshmand.net/favicon.png\"><span class=\"kg-bookmark-author\">Dana Hooshmand</span><span class=\"kg-bookmark-publisher\">HOOSHMAND.NET</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://hooshmand.net/content/images/2019/10/Contact-forms-in-Ghost-in-HTML---FB-Cover-1.jpg\"></div></a></figure><p>I took his html and style files as a starting point as you will see later.</p><h2 id=\"run-your-own-service\">Run your own service</h2><p>I am going to implement a micro-service using <code>node.js</code> with <code>express</code>, <code>body-parser</code>, and <code>nodemailer</code>. All it needs to do is listen for a post request on route<strong> </strong><code>/v1/contact</code>, collect the form data and send it to an email address of your choosing.</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-javascript\">var app = express();\n\napp.use(cors({origin: process.env.ALLOW_ORIGIN, allowedHeaders: ['Content-Type', 'application/json']}));\n\napp.post('/v1/contact', function(req, res) {\n    if(validator.validate(req.body.email)) return sendEmail(req.body, res);  \n    res.status(403).json({\"validation\": \"no email\"});\n});\n\napp.listen(process.env.PORT || 7000, function(){\n\tconsole.log('Listening on http://localhost:' + (process.env.PORT || 7000));\n});</code></pre><figcaption>ghost-contact-svc.js (server part)</figcaption></figure><p>As you can see, the service listens on port <code>7000</code>, and calls the function <code>sendEmail()</code>, if a correct email was provided. Note that we define <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS\">CORS headers</a>, which should be set to your blog URL in the environment variable <code>ALLOW_ORIGIN</code>. </p><p>While the <code>validate()</code><strong> </strong>function is taken from a node package, we need to put together the email data in <code>sendEmail()</code> ourselves:</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-javascript\">function sendEmail(data, res){\n    var email = { \"from\": process.env.EMAIL_FROM, \"to\": process.env.EMAIL_TO};\n    email.subject = 'MY BLOG - ' + (data.subject &amp;&amp; data.subject.toUpperCase());\n\n    const output = `\n        &lt;p&gt;Hello,&lt;p&gt;\n        &lt;p&gt;You got a new contact request.&lt;/p&gt;\n        &lt;h3&gt;Contact Details&lt;/h3&gt;\n        &lt;ul&gt;&lt;li&gt;Name: ${data.name}&lt;/li&gt;&lt;li&gt;Email: ${data.email}&lt;/li&gt;&lt;/ul&gt;\n        &lt;h3&gt;Message:&lt;/h3&gt;\n        &lt;p&gt;${data.message}&lt;/p&gt;\n    `\n    email.html = sanitize(output, { \n    \tallowedTags: sanitize.defaults.allowedTags.concat([ 'img' ])\n\t});\n    transporter.sendMail(email, function(error, info){\n        if(error) return res.json({\"sendEmail\": \"failed\"});\n        res.json({\"sendEmail\": \"ok\"});\n    });\n};</code></pre><figcaption>ghost-contact-svc.js (email sending part)</figcaption></figure><p>Basically, I am putting the provided data into a html message, sanitize it to prevent malicious code injections and send it to the configured email address. The configuration must be provided in a <code><strong>.env</strong></code><strong> </strong><a href=\"https://www.npmjs.com/package/dotenv\">file</a> in the working directory, where the following six variables are specified:</p><figure class=\"kg-card kg-code-card\"><pre><code>SMTP_HOST = mail.server.com\nSMTP_USER = user@server.com\nSMTP_PASS = strong password\nALLOW_ORIGIN = https://your-blog.com\nEMAIL_FROM = noreply@your-blog.com\nEMAIL_TO = your@email.com</code></pre><figcaption>.env file (replace variables with your own data)</figcaption></figure><p>Putting it all together and adding some rate limits, the back-end script can be written in only fifty code lines:</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-javascript\">'use strict';\nvar express    = require('express');\nvar cors       = require('cors');\nvar bodyParser = require(\"body-parser\");\nvar dotenv     = require('dotenv').config();\nvar nodemailer = require('nodemailer');\nvar smtpTrans  = require('nodemailer-smtp-transport');\nvar validator  = require(\"email-validator\");\nvar sanitize   = require('sanitize-html');\n\nvar smtp  = { \"auth\": {}, \"port\": 465, \"secure\": true, \"tls\": {\"rejectUnauthorized\": false}, \"debug\": false};\nsmtp.host      = process.env.SMTP_HOST;\nsmtp.auth.user = process.env.SMTP_USER;\nsmtp.auth.pass = process.env.SMTP_PASS;\nvar transporter = nodemailer.createTransport(smtpTrans(smtp));\n\nvar app = express();\napp.disable('x-powered-by');\napp.use(bodyParser.urlencoded({limit: '1mb', extended: false}));\napp.use(bodyParser.json({limit: '1mb'}));\napp.use(cors({origin: process.env.ALLOW_ORIGIN, allowedHeaders: ['Content-Type', 'application/json']}));\n\napp.post('/v1/contact', function(req, res) {\n    if(validator.validate(req.body.email)) return sendEmail(req.body, res);  \n    res.status(403).json({\"validation\": \"no email\"});\n});\n\napp.listen(process.env.PORT || 7000, function(){\n\tconsole.log('Listening on http://localhost:' + (process.env.PORT || 7000));\n});\n\nfunction sendEmail(data, res){\n    var email = { \"from\": process.env.EMAIL_FROM, \"to\": process.env.EMAIL_TO};\n    email.subject = 'MY BLOG - ' + (data.subject &amp;&amp; data.subject.toUpperCase());\n\n    const output = `\n        &lt;p&gt;Hello,&lt;p&gt;\n        &lt;p&gt;You got a new contact request.&lt;/p&gt;\n        &lt;h3&gt;Contact Details&lt;/h3&gt;\n        &lt;ul&gt;&lt;li&gt;Name: ${data.name}&lt;/li&gt;&lt;li&gt;Email: ${data.email}&lt;/li&gt;&lt;/ul&gt;\n        &lt;h3&gt;Message:&lt;/h3&gt;\n        &lt;p&gt;${data.message}&lt;/p&gt;\n    `\n    email.html = sanitize(output, { \n    \tallowedTags: sanitize.defaults.allowedTags.concat([ 'img' ])\n\t});\n    transporter.sendMail(email, function(error, info){\n        if(error) return res.json({\"sendEmail\": \"failed\"});\n        res.json({\"sendEmail\": \"ok\"});\n    });\n};</code></pre><figcaption>ghost-contact-svc.js (working node micro-service)</figcaption></figure><p>With the two files above, namely <code>.env</code><strong> </strong>and <code>ghost-contact-svc.js</code> it's time to put the service to a first test.</p><h2 id=\"quick-install\">Quick Install</h2><p>I assume that you have <a href=\"https://nodejs.org\">node.js</a> installed on your system as you had to do this before when you installed Ghost.</p><p>Now, put the two files from above, namely <code>ghost-contact-svc.js</code> and <code>.env</code><strong> </strong>into an empty work directory and add the bash script <code>install.sh</code> to it.</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-bash\">#!/bin/bash\n\nsudo npm -g install depcheck \nnpm -y init\ndeps=$(depcheck |cut -d: -f1 |tr -d '* ' | tail -n +2)\n\nfor package in ${deps[@]}; do\n\techo 'Installing package: ' ${package}\n\tnpm install ${package} --save\ndone</code></pre><figcaption>install.sh (also make the file executable with \"chmod +x install.sh\")</figcaption></figure><p>When you execute the script with <code>./install.sh</code>, it installs a dependency checker and subsequently downloads all needed node packages for this project. It also automatically creates the project manifest <code>package.json</code>. <em>Feel free to use this script in all your other node.js projects :-).</em></p><h2 id=\"fire-up-your-service\">Fire up your service</h2><p>It is time to fire up the service with this one liner:</p><pre><code>&gt; node ghost-contact-svc.js\nListening on http://localhost:7000</code></pre><p>If all goes well, you are greeted from your service accepting new incoming requests on port <code>7000</code>. The service listens forever, but you can always exit it with <code>Ctrl+C</code>. For now, just leave it as is and open a new terminal window for testing.</p><h2 id=\"first-light\">First Light</h2><p>As a first test, use a simple curl post request as follows:</p><pre><code>&gt; curl -v -d '{\"email\": \"test@example.com\", \"name\": \"John Izzo\", \"subject\": \"feedback\", \"message\": \"First Light!\"}' -H \"Content-Type: application/json\" -X POST http://localhost:7000/v1/contact</code></pre><p>If the output ends with <code>{\"sendEmail\":\"ok\"}</code> you can go check your inbox, you should have received a new message:</p><figure class=\"kg-card kg-image-card\"><img src=\"https://atmolabs.org/content/images/2020/01/image-2.png\" class=\"kg-image\"></figure><p>Be a bit playful, send some crappy data to your service, omit some json key/value pairs, add some that are not recognized and try to break your service. <em>I was not able to break it, but </em>p<em>lease report back to me, if you find a way to crash the service!</em></p><p>Watch out for some typical issues that you might run into during initial set-up. If you misconfigured the smtp credentials, you'll see a <code>{\"sendEmail\":\"failed\"}</code> response. If the email validation fails, you'll get a simple <code>{\"validation\":\"no email\"}</code> response.</p><h2 id=\"deploy-it-as-a-side-car-to-ghost\">Deploy it as a side-car to Ghost</h2><p>While testing on your local machine is great, eventually you want to make this service available to the world. I suggest you place it behind your blog domain <code>api.your-blog.com</code> so you do not interfere with Ghost's routes.</p><p>I use <code>nginx</code> as a reverse proxy with a configuration that looks similar to:</p><figure class=\"kg-card kg-code-card\"><pre><code>server {\n\n  listen 443 ssl http2;\n  listen [::]:443 ssl http2;\n\n  server_name api.your-blog.com;\n\n  ssl_certificate /etc/letsencrypt/live/your-blog.com/fullchain.pem;\n  ssl_certificate_key /etc/letsencrypt/live/your-blog.com/privkey.pem;\n  ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n\n  location / {\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    proxy_set_header Host $http_host;\n    proxy_set_header X-Forwarded-Proto $scheme;\n    proxy_set_header X-Real-IP $remote_addr;\n    proxy_pass http://127.0.0.1:7000;\n  }\n\n}</code></pre><figcaption>/etc/nginx/conf.d/api.conf</figcaption></figure><p>Once <code>/etc/nginx/conf.d/api.conf</code> is created, <code>nginx</code> must be reloaded with <code>systemctl restart nginx</code> for the changes to take effect. Finally, don't forget to punch an outgoing (not incoming!) whole in your firewall on port <code>465</code>, otherwise you cannot reach the external smtp server.</p><p>In production, <code>ghost-contact-svc.js</code> must be run as a daemon. I use the following <code>systemd</code> unit for this purpose where you need to modify the <code>User=</code> and <code>ExecStart=</code> lines:</p><figure class=\"kg-card kg-code-card\"><pre><code>[Unit]\nDescription=Contactor microservice\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=always\nRestartSec=1\nUser=jo\nExecStart=/usr/bin/env node /home/jo/ghost-contact-form/ghost-contact-svc.js\n\n[Install]\nWantedBy=multi-user.target</code></pre><figcaption>/etc/systemd/system/ghost-contact.service</figcaption></figure><p>The service is started with <code>systemctl start ghost-contact</code> and made persistent with <code>systemctl enable ghost-contact</code>.</p><p>Once everything is in place and the service is running, test it from outside your remote server with a couple of curl requests.</p><pre><code>&gt; curl -v -d '{\"email\": \"test@example.com\", \"name\": \"John Izzo\", \"subject\": \"feedback\", \"message\": \"Production Light!\"}' -H \"Content-Type: application/json\" -X POST https://api.your-blog.com/v1/contact</code></pre><h2 id=\"a-word-on-security-and-spamming\">A word on security and spamming</h2><p>The implemented CORS headers will prevent other people from being able to consume your micro-service from <em>their websites</em>. That's a great security feature used by all modern browsers. Unfortunately, it won't hold off any script-kiddies.</p><p><em>Your endpoint is publicly available</em> and can therefore be accessed by anyone from <em>custom built scripts</em>. In fact, you can test that easily yourself with the <code>curl</code> command as shown above.</p><blockquote>Actually, you might be surprised that there is no bullet proof method to prevent spammers from sending fake data to your endpoint.</blockquote><p>A common way to guard against those unwanted requests is to add a <em>captcha challenge</em> to your service at the expense of a really bad user experience.</p><p>If need be, look into implementing <em>temporary tokens</em>, or into the myriad of honey-spot techniques.</p><h2 id=\"it-s-super-easy-to-extend-the-service\">It's super easy to extend the service</h2><p>To showcase that this service is like a Swiss army knife, I show you how to turn it into a <strong>static asset provider</strong> with <em>just one additional code line. </em>Add this line in <code>ghost-contact-svc.js</code> directly below the other <code>app.use()</code> instructions:</p><pre><code class=\"language-javascript\">app.use('/v1/assets', express.static(__dirname + '/assets'));</code></pre><p>Files that you put into a folder named <code>assets</code> (which must reside in the same directory as your service code), will now be served at <code>https://api.your-blog.com/v1/assets</code>. </p><p>Awesome! All your custom files can now be served from one place. No need to mess around with any Ghost directories. This will come in handy in a moment, when I provide the front-end code and style files.</p><h2 id=\"front-end-matters\">Front-end matters</h2><p>If you use Ghost in its default configuration, your new contact page can be configured directly in the Ghost Admin interface. Navigate to the Ghost <code>Pages</code> section and add a new page by clicking the <code>New page</code> button. Immediately, the page editor opens and you can type in a title, some introductory text or add some images.</p><p>Next, click on the circle icon, choose the html block and paste the following snippet in:</p><pre><code class=\"language-html\">&lt;form id=\"contact-form\" method=\"post\" data-format=\"inline\"&gt;\n    &lt;input type=\"text\" id=\"name\" placeholder=\"Full Name\" pattern=\".{2,30}\" required&gt;\n    &lt;input type=\"email\" id=\"email\" placeholder=\"Email Address\" required&gt;\n    &lt;select id=\"subject\" pattern=\".{1,20}\" required&gt;\n        &lt;option value=\"\" disabled selected&gt;Please select...&lt;/option&gt;\n        &lt;option value=\"comment\"&gt;I want to give feedback&lt;/option&gt;\n        &lt;option value=\"question\"&gt;I want to ask a question&lt;/option&gt;\n    &lt;/select&gt;\n    &lt;textarea rows=\"5\" id=\"message\" placeholder=\"Message\" pattern=\".{10,4000}\" required&gt;&lt;/textarea&gt;\n    &lt;input type=\"text\" name=\"_norobots\" style=\"display:none !important;\"&gt;\n    &lt;button class=\"btn\" type=\"submit\"  id=\"submit\" value=\"Send\" onclick=\"formProcessor.process();return false;\"&gt;Send&lt;/button&gt;\n    &lt;span id=\"responsemsg\"&gt;&lt;/span&gt;\n&lt;/form&gt;</code></pre><p>There are a couple of things worth noting here:</p><ul><li>The form has no styling and looks quite ugly yet. I will provide a <code>css</code> style file to beautify it.</li><li>The input line with name <code>_norobots</code> is not shown to human users, but is there to detect robots if they fill out this field (a simple honeyspot technique).</li><li>Some basic <code>html5</code> validation is added to the form, so browsers automatically apply some styling, if rules are violated.</li><li>All the magic happens when the user hits the <code>Send</code> button and <code>formProcessor.process()</code> is triggered.</li></ul><h2 id=\"beautiful-styling-please-\">Beautiful styling, please!</h2><p>As mentioned earlier, I'm going to use the form style that Dana created for his blog article with some minor modifications:</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-css\">form,input,select,textarea,button {\n    font-family: avenir next,avenir,helvetica neue,helvetica,ubuntu,roboto,noto,segoe ui,arial,sans-serif;\n\tdisplay: block;\n\tmargin: 0 0 2rem 0;\n    padding: 1rem 0;\n    width: 100% !important;\n    align-items: flex-start;\n    box-sizing: border-box;\n}\ninput,select,textarea {\n    color: darkslategray;\n    background-color: white;\n    background-clip: padding-box;\n    line-height: 1.5;\n    border-radius: .5rem;\n    padding: 1rem 4rem;\n    border: 1px solid #ced4da;\n    transition: border-color .15s ease-in-out,box-shadow .15s ease-in-out;\n}\nselect {\n    appearance: none;\n    -moz-appearance: none; \n    -webkit-appearance: none; \n}\nselect:required:invalid {\n\tcolor: silver;\n}\ninput:focus, select:focus, textarea:focus {\n    border-color: royalblue;\n    box-shadow: none;\n    -webkit-box-shadow: none;\n}\nbutton {\n    margin-bottom: 0;\n    color: white;\n    background-color: royalblue;\n    border-color: royalblue;\n    user-select: none;\n    line-height: 1.5;\n    border-radius: .5rem;\n    border: 1px solid transparent;\n    transition: color .15s ease-in-out,background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out;\n}\nbutton:hover { \n\tfilter: brightness(80%); \n}\ninput:placeholder { \n\tcolor: silver; \n}\noption[value=\"\"][disabled] {\n    display: none;\n    color: silver;\n}\noption {\n    color: black;\n}</code></pre><figcaption>ghost-contact.css</figcaption></figure><p>If you feel fancy, you can minify this style file before putting it into the <code>asset</code> directory of your micro-service. Make sure you can reach it under the route <code>https://api.your-blog.com/v1/assets/ghost-contact.css</code>. Here is the end result:</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://atmolabs.org/content/images/2020/02/image.png\" class=\"kg-image\"><figcaption>Run the demo yourself - https://github.com/styxlab/ghost-contact-form</figcaption></figure><h2 id=\"linking-the-front-end-to-the-back-end\">Linking the front-end to the back-end</h2><p>It's time to look into the <code>formProcessor</code> which is just a bit of client side javascript code. As I want to keep the back-end as lean as possible, I also add a bit of client side validation.</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-javascript\">var formProcessor = (function(){\n\n  \"use strict\";\n\n  var constraints = {\n      name: {\n          presence: true,\n          length: {\n              minimum: 2,\n              maximum: 30,\n              message: \"must be longer.\"\n            }\n        },\n      email: {\n        presence: true,\n        email: true,\n      },\n      subject: {\n        presence: true,\n        length: {\n          minimum: 1,\n            message: \"must be selected.\"\n          }\n      },\n      message: {\n        presence: true,\n          length: {\n               minimum: 10,\n               maxumum: 4000,\n               message: \"must be longer.\"\n            }\n      },\n      robot: {\n        presence: true,\n        length: {\n               is: 0,\n               message: \"must be filled out.\"\n            }\n      }\n  };\n\n  function formAlert(text) {\n      document.getElementById(\"responsemsg\").innerHTML = \"&lt;br&gt;&lt;p&gt;&lt;em&gt;\" + text + \"&lt;/em&gt;&lt;/p&gt;\";\n    };\n\n  function sendData(data) {\n    formAlert(\"One second...\");\n    var postURL = \"https://api.your-blog.com/v1/contact\";\n    var http = new XMLHttpRequest();\n    http.open(\"POST\", postURL, true);\n    http.setRequestHeader(\"Content-Type\", \"application/json\");\n    data.source_url = window.location.href;\n    http.send(JSON.stringify(data));\n    http.onload = function() {\n        formAlert(\"Thank you, your message has been sent!\");\n        document.getElementById(\"contact-form\").reset();\n    }\n  };\n\n  return ({\n    process: function() {\n        var attributes = {\n        name: document.forms[\"contact-form\"][\"name\"].value,\n        email: document.forms[\"contact-form\"][\"email\"].value,\n        subject: document.forms[\"contact-form\"][\"subject\"].value,\n        message: document.forms[\"contact-form\"][\"message\"].value,\n        robot: document.forms[\"contact-form\"][\"_norobots\"].value\n      };\n      validate.async(attributes, constraints)\n      .then(function(success) {\n          console.log(\"Success\", success);\n          sendData(success);\n      })\n      .catch(function(error) {\n        console.log(\"ValidationError\", error);\n        formAlert(Object.values(error)[0][0]);\n      })  \n    }\n  });\n\n}());\n</code></pre><figcaption>formProcessor.js</figcaption></figure><p>Read this file from bottom to top, starting with the <code>process()</code> function. Basically, I collect the form data into the variable <code>attributes</code> which is subsequently validated against some <code>constraints</code>. Only if the constraints are met, do we initiate the <code>sendData()</code> function. </p><p>Download the package <code><a href=\"https://validatejs.org/validate.min.js\">validate.min.js</a></code> and put this file together with <code>formProcessor.js</code> into the asset folder so it gives the style file some nice company.</p><p>The magic link is made in function <code>sendData()</code> where the form data is send over to our micro-service via the familiar route <a href=\"https://your-blog.com/api/v1/contact\"><code>https://api.your-blog.com/v1/contact</code></a>. This replaces the <code>curl</code> requests that we used for testing before.</p><h2 id=\"ghost-code-injection\">Ghost Code Injection</h2><p>Finally, all front-end files must be included in the loading of your contact page. This is easily achieved by the following code injections.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://atmolabs.org/content/images/2020/01/image-3.png\" class=\"kg-image\"><figcaption>Ghost Admin Interface - Contact page</figcaption></figure><p>Inject this snippet into the Ghost <code>Page header</code> of your contact page:</p><pre><code class=\"language-html\">&lt;link rel=\"stylesheet\" href=\"https://api.your-blog.com/v1/assets/ghost-contact.css\"&gt;</code></pre><p>Likewise inject this snippet into the <code>Page footer</code> of your page: </p><pre><code class=\"language-html\">&lt;script src=\"https://api.your-blog.com/v1/assets/validate.min.js\" type=\"text/javascript\"&gt;&lt;/script&gt;\n&lt;script src=\"https://api.your-blog.com/api/assets/formProcessor.js\" type=\"text/javascript\"&gt;&lt;/script&gt;  </code></pre><p>That's it. <em>Your beautiful form should be fully functional!</em></p><h2 id=\"unique-features-of-this-solution\">Unique Features of this Solution</h2><p>While running your own micro-service is more involved than subscribing to an externally hosted service, the solution shines with these noteworthy benefits:</p><ul><li>Your visitor's <em>contact data remains with you</em> and is not shared with any third party providers.</li><li>You have full control of the <em>data</em> and <em>code</em> of your service.</li><li>The solution is written with <em>standard web tools</em> and <em>can be easily extended and adapted</em> to ever changing needs.</li><li>The <em>Ghost installation is completely unaltered</em>, which will save you multiple headaches during the next updates and future upgrades. </li><li>The same principle can be used to enhance your Ghost blog with other <em>self-built services acting as integrations, plugins or addons.</em></li><li><em>No additional costs</em>, if you run your micro-service on the same server where you host your Ghost blog software.</li></ul><h2 id=\"conclusions\">Conclusions</h2><p>With this guide, you should be able to set-up a fully functional contact page in Ghost without locking into another external service provider. I also created the <a href=\"https://github.com/styxlab/ghost-contact-form\">ghost-contact-form</a> solution on Github, where further code improvements will be made.</p><p>While I focus on Ghost in this article, ghost-contact-form is actually also an ideal solution for any other <a href=\"https://www.staticgen.com/\">static site generators</a>, like <a href=\"https://www.gatsbyjs.org/\">Gatsby</a>, <a href=\"https://gohugo.io/\">Hugo</a>, <a href=\"https://hexo.io/\">Hexo</a> and others. Only the front-end needs to be adjusted, the <em>back-end stays completely the same</em>!</p><p>One more thing...</p><p>...if you want to see <a href=\"https://github.com/styxlab/ghost-contact-form\">ghost-contact-form</a> in action, don't forget to drop me a line on our <a href=\"https://atmolabs.org/contact/\">Contact Us</a> page!</p>
